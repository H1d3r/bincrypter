# This hook is base64 encoded and slurped into bincrypter.sh
# Bincrypter.sh eventually adds it to the encrypted binary (header).

for x in openssl perl gunzip; do
    command -v "$x" >/dev/null || { echo >&2 "ERROR: Command not found: $x"; return 255; }
done
_PASSWORD="${BCP:-$PASSWORD}"
# Ask perl to keep \n because openssl base64 -d expects it
[ -n "$P" ] && {
    _PASSWORD="$(echo "$P"|LANG=C perl -pe 's/[^[:print:]\n]//g;'|openssl base64 -A -d)"
    unset P
}
[ -z "$_PASSWORD" ] && {
    # BASH + ZSH compat
    echo >&2 -n "Enter password: "
    read -r _PASSWORD
}

# Check if file is sourced or executed
# - if executed then we are using /bin/sh and ZSH/BASH-version are _not_ set.
if [ -n "$ZSH_VERSION" ]; then
    [ "$ZSH_EVAL_CONTEXT" != "${ZSH_EVAL_CONTEXT%":file:"*}" ] && fn="$0"
elif [ -n "$BASH_VERSION" ]; then
    (return 0 2>/dev/null) && fn="${BASH_SOURCE[0]}"
else
    # Tricky bit to detect if sourced on BusyBox.
    # - This part might be evaluated (eval()) from /bin/sh
    # - If executed then $0 is the script name. If sourced then $0=sh
    #   and BusyBox does not tell us which file was sourced.
    # FIXME: could make something crazy like:
    # eval "$(BC_OUTPUT=1 ./SCRIPTNAME)"
    [ ! -f "$0" ] && { echo >&2 'ERROR: Shell not supported. Use Bash or Zsh instead.'; return 255; }
fi

prg="perl -e '<>;<>;print(<>)'<'${fn:-$0}'|openssl enc -d %%SSL_OPTS%% '${S}-${_PASSWORD}' 2>/dev/null|gunzip"
[ -n "$fn" ] && {
    # Bourne shell does not allow 'source' or '<(':
    # source <(unset _ _PASSWORD S prg fn;LANG=C perl -e '<>;<>;print(<>)'<"${fn}"|openssl enc -d %%SSL_OPTS%% "$_PASSWORD" 2>/dev/null|gunzip)
    # Alternative 1:
    eval "unset _ _PASSWORD S prg fn;$(LANG=C perl -e '<>;<>;print(<>)'<"${fn}"|openssl enc -d %%SSL_OPTS%% "${S}-${_PASSWORD}" 2>/dev/null|gunzip)"
    # Alternative 2:
    # eval "unset _ _PASSWORD S prg fn;$(LANG=C perl -e 'open($i,"'"$prg"'|");print(<$i>);')"
    return
}

### HERE: it's not sourced. Execute instead.
# bourne shell exports _ by default. It contains binary garbage. Remove.
unset _ PASSWORD S # do not leak into new process
# Leak BCP on purpose to allow nested-decryption.

# Note: The 2nd LANG is the original/correct and _not_ set to C.
# FIXME: if gunzip fails then perl will exit with 0 and not 255.
LANG=C exec perl '-e$^F=255;for(319,279,385,4314,4354){($f=syscall$_,$",0)>0&&last};open($o,">&=".$f);open($i,"'"$prg"'|");print$o(<$i>);close($i)||exit($?/256);$ENV{"LANG"}="'"$LANG"'";exec{"/proc/$$/fd/$f"}"'"${0:-python3}"'",@ARGV' -- "$@"
